AI - LAB MANUAL RECORD DOCUMENT OF PROGRAMS
                                      AI-CSA1783

NAME:-  T.Hari Krishna                            Reg no:- 192111563

Program-1:

AIM :

To perform 8 puzzle problem using python programming

ALGORITHM:
 STEP1:State Representation: Represent the puzzle as a 3x3 grid, where each cell contains a number (1-8) or is empty (0).
 STEP2: Node Representation: Each node in the search tree represents a state of the puzzle. It contains the current state, the previous state (parent), the move that led to this state, and the cost (usually the sum of the path cost and a heuristic estimate).
 STEP 3:Heuristic Function: Choose a heuristic function that estimates the cost from the current state to the goal state. A common heuristic for the 8-puzzle is the Manhattan distance, which is the sum of the horizontal and vertical distances of each tile to its correct position.
STEP4: Priority Queue: Use a priority queue (e.g., a min-heap) to store nodes during the search. Nodes are dequeued based on their total cost (p222ath cost + heuristic cost).
STEP5: A Algorithm*: a. Initialize the priority queue with the initial state. b. While the priority queue is not empty: i. Dequeue the node with the lowest total cost. ii. If the current state is the goal state, the solution is found. iii. Generate successor states by moving the empty space in all possible directions (up, down, left, right). iv. For each successor state: - Calculate the cost (path cost + heuristic cost).
STEP 6:Solution Extraction: Once the goal state is reached, follow the parent pointers from the goal node to the initial node to extract the sequence of moves that lead to the solution.
 
SOURCE CODE :
import copy
from heapq import heappush, heappop
n = 3
row = [ 1, 0, -1, 0 ]
col = [ 0, -1, 0, 1 ]
class priorityQueue:
      	def __init__(self):
                            	self.heap = []
            	def push(self, k):
                            	heappush(self.heap, k)
            	def pop(self):
                            	return heappop(self.heap)
            	def empty(self):
                            	if not self.heap:
                                            	return True
                            	else:
                                            	return False
class node:
            	
            	def __init__(self, parent, mat, empty_tile_pos,
                                                            	cost, level):
                            	self.parent = parent
                            	self.mat = mat
                            	self.empty_tile_pos = empty_tile_pos
                            	self.cost = cost
                            	self.level = level
            	def __lt__(self, nxt):
                            	return self.cost < nxt.cost
def calculateCost(mat, final) -> int:
            	
            	count = 0
            	for i in range(n):
                            	for j in range(n):
                                            	if ((mat[i][j]) and
                                                            	(mat[i][j] != final[i][j])):
                                                            	count += 1
                                                            	
            	return count
 
def newNode(mat, empty_tile_pos, new_empty_tile_pos,
                                            	level, parent, final) -> node:
            	new_mat = copy.deepcopy(mat)
            	x1 = empty_tile_pos[0]
            	y1 = empty_tile_pos[1]
            	x2 = new_empty_tile_pos[0]
            	y2 = new_empty_tile_pos[1]
            	new_mat[x1][y1], new_mat[x2][y2] = new_mat[x2][y2], new_mat[x1][y1]
            	cost = calculateCost(new_mat, final)
 
            	new_node = node(parent, new_mat, new_empty_tile_pos,
                                                                            	cost, level)
            	return new_node
def printMatrix(mat):
            	
            	for i in range(n):
                            	for j in range(n):
                                            	print("%d " % (mat[i][j]), end = " ")
                                            	
                            	print()
def isSafe(x, y):
            	
            	return x >= 0 and x < n and y >= 0 and y < n
def printPath(root):
            	
            	if root == None:
                            	return
            	
            	printPath(root.parent)
            	printMatrix(root.mat)
            	print()
def solve(initial, empty_tile_pos, final):
            	pq = priorityQueue()
            	cost = calculateCost(initial, final)
            	root = node(None, initial,
                                                            	empty_tile_pos, cost, 0)
 
            	pq.push(root)
            	while not pq.empty():
                            	minimum = pq.pop()
                            	if minimum.cost == 0:
                                            	printPath(minimum)
                                            	return
                            	for i in range(4):
                                            	new_tile_pos = [
                                                            	minimum.empty_tile_pos[0] + row[i],
                                                            	minimum.empty_tile_pos[1] + col[i], ]
                                                            	
                                            	if isSafe(new_tile_pos[0], new_tile_pos[1]):
                                                            	child = newNode(minimum.mat,
                                                                                                                            	minimum.empty_tile_pos,
                                                                                                                            	new_tile_pos,
                                                                                                                            	minimum.level + 1,
                                                                                                                            	minimum, final,)
                                                            	pq.push(child)
 
initial = [ [ 1, 2, 3 ],
                                            	[ 5, 6, 0 ],
                                            	[ 7, 8, 4 ] ]
 
final = [ [ 1, 2, 3 ],
                            	[ 5, 8, 6 ],
                            	[ 0, 7, 4 ] ]
empty_tile_pos = [ 1, 2 ]
 
solve(initial, empty_tile_pos, final)

OUTPUT:
 
RESULT:
The program to execute 8 puzzle program is executed successfully in python

PROGRAM 2:
Write the python program to solve 8-Queen problem

AIM: To write a python to solve 8-Queen problem

Algorithm:
Step 1:Board Representation: Represent the chessboard as an 8x8 grid, where each cell can be either empty or occupied by a queen.
Step 2:   Place Queen Function: Implement a function that attempts to place a queen in a given row. This function should check if the placement is valid by ensuring that no other queens threaten the newly placed queen.
Step 3: Backtracking Algorithm: a. Start with an empty chessboard. b. For each row from 0 to 7: i. Call the "Place Queen" function for the current row. ii. If a valid placement is found, move to the next row. iii. If no valid placement is found, backtrack to the previous row and continue searching for valid placements. c. If a valid placement is found for all rows, a solution is found.
 Step 4:   Recursion and Backtracking: a. The "Place Queen" function:
 i. Given a row, try placing a queen in each column of that row. 
ii. Check if the placement is valid by ensuring that no other queens threaten the newly placed queen. 
iii. If the placement is valid, mark the cell as occupied by a queen and move to the next row recursively. 
iv. If no valid placement is found in the current row, backtrack by removing the queen from the cell and returning to the previous row.
 Step 5:    Solution Extraction: Once a solution is found, you can extract the positions of the queens on the board to visualize the solution.

Program:
# Taking number of queens as input from user
print ("Enter the number of queens")
N = int(input())

# here we create a chessboard
# NxN matrix with all elements set to 0
board = [[0]*N for _ in range(N)]

def attack(i, j):
    #checking vertically and horizontally
    for k in range(0,N):
        if board[i][k]==1 or board[k][j]==1:
            return True
    #checking diagonally
    for k in range(0,N):
        for l in range(0,N):
            if (k+l==i+j) or (k-l==i-j):
                if board[k][l]==1:
                    return True
    return False

def N_queens(n):
    if n==0:
        return True
    for i in range(0,N):
        for j in range(0,N):
            if (not(attack(i,j))) and (board[i][j]!=1):
                board[i][j] = 1
                if N_queens(n-1)==True:
                    return True
                board[i][j] = 0

    return False

N_queens(N)
for i in board:
    print (i)

Output:
 
Result:
The program to execute 8 queen program is executed successfully in python.

PROGRAM 3:

Write the python program for Water Jug Problem

AIM: To write a Python program to create water jug problem.
ALGORITHM: 
STEP1:start the program 
Step2:give the required commands for vacuum cleaner 
Step3:Initialize two variables j1 and j2 to represent the current amount of water in each jug.
Step4:Set a target amount of water to measure out.
Step5:Create a list of possible actions, including filling a jug, emptying a jug, and pouring      water from one jug to the other.
Step6: Create an empty set to keep track of visited states.
Step7:Create a stack to keep track of states to visit, and add the initial state to the stack.

PROGRAM:
class VacuumCleaner:
    def __init__(self):
        self.position = 0  # Position of the vacuum cleaner (0: Left, 1: Right)
        self.environment = [0, 0]  # Environment with dirty cells (0: Clean, 1: Dirty)

    def sense(self):
        return self.environment[self.position]

    def move(self):
        if self.position == 0:
            self.position = 1
        else:
            self.position = 0

    def clean(self):
        self.environment[self.position] = 0

    def run(self, steps):
        for _ in range(steps):
            current_state = self.sense()
            if current_state == 1:  # Dirty cell
                self.clean()
                print(f"Cleaned cell {self.position}")
            else:
                print(f"Cell {self.position} is already clean.")
            self.move()


if __name__ == "__main__":
    vacuum_cleaner = VacuumCleaner()
    steps = 5
    print("Initial environment:", vacuum_cleaner.environment)
    vacuum_cleaner.run(steps)
    print("Final environment:", vacuum_cleaner.environment)

OUTPUT:
 
RESULT:
The program to execute vacuum cleaner is executed successfully in python.

PROGRAM-4:

AIM: python program for Cript-Arithmetic problem.
ALGORITHM:
STEP1:start the program 
STEP 2:Generate all possible combinations of digit assignments for the letters involved.
STEP 3:For each combination, check if the equation holds true.
STEP 4:Print the combination that satisfies the equation.
STEP5:end the program.

SOURCE CODE:
def is_valid_assignment(assignment, letters):
    # Check if the assignment is valid (no repeated digits)
    values = list(assignment.values())
    return len(values) == len(set(values))

def evaluate_expression(expression, assignment):
    # Evaluate the expression using the given assignment
    value = 0
    for char in expression:
        value = value * 10 + assignment[char]
    return value

def solve_cryptarithmetic(equation):
    words = equation.replace("+", " ").replace("=", " ").split()
    unique_letters = set("".join(words))
    leading_letters = set(word[0] for word in words)
    letters = list(unique_letters)
    
    # Try all possible digit assignments
    from itertools import permutations
    for perm in permutations(range(10), len(letters)):
        assignment = dict(zip(letters, perm))
        
        if all(assignment[letter] != 0 for letter in leading_letters):
            left_value = evaluate_expression(words[0], assignment)
            right_value = evaluate_expression(words[1], assignment)
            result_value = evaluate_expression(words[2], assignment)
            
            if left_value + right_value == result_value:
                return assignment
    
    return None

# Example problem: SEND + MORE = MONEY
equation = "SEND + MORE = MONEY"
solution = solve_cryptarithmetic(equation)

if solution:
    print("Solution found:")
    for letter, digit in solution.items():
        print(f"{letter}: {digit}")
else:
    print("No solution found.") 
OUTPUT:
 

RESULT:
The program to solve is executed successfully in python

PROGRAM-5:
AIM:
Python program for Missionaries Cannibal problem.

ALGORITHM:
STEP1: One way to solve the Missionaries and Cannibals problem is to use a variation of the Breadth-First Search (BFS) algorithm.
 STEP2:The idea is to represent the states of the problem (the number of missionaries and cannibals on each side of the river and the boat's location) as nodes in a graph.
 STEP3:Then, by systematically exploring the graph using BFS, you can find a valid sequence of moves that solves the problem.

SOURCE CODE:
start,end =[3,3,1],[0,0,0]
def do_action(state,action):
    if state[2] == 1:
        return [state[i] - action[i] for i in range(3)]
    else:
        return [state[i] + action[i] for i in range(3)]
def is_legal(state):
    if 0 <= state[0] <= 3 and 0 <= state[1] <= 3:
        return True
    else:
        return False
def is_bank_safe(bank):
    if bank[1] > bank[0] and bank[0] != 0:
        return False
    else:
        return True
def is_state_safe(state):
    other_bank = [start[i]-state[i] for i in range(3)]
    if is_bank_safe(state) and is_bank_safe(other_bank) :
        return True
    else:
        return False
def next_possible_actions(state):
    actions = [[1,0,1],[0,1,1],[1,1,1],[2,0,1],[0,2,1]]
    moves = []
    for i in actions:
        j = do_action(state,i)
        if is_legal(j) and is_state_safe(j):
            moves.append(j)
    return moves
solutions = []
def solve(next_action,path):
    _path = path.copy()
    if next_action == end:
        _path.append(next_action)
        solutions.append(_path)
        return
    elif next_action in path:
        return
    else:
        _path.append(next_action)
        for i in next_possible_actions(next_action):
            solve(i,_path)

solve([3,3,1],[])
print(*solutions,sep="\n")
OUTPUT:
 

RESULT:
The program  for Missionaries Cannibal problem is executed successfully in python.

PROGRAM-6:
AIM: python program for Vacuum Cleaner problem.

ALGORITHM:
STEP1: Initialize: Start at a given position on the grid.
STEP 2:Check and Clean: If the current cell is dirty, clean it.
STEP 3:Move Decision: Choose the next cell to move to. Options include:
Move to the nearest dirty cell.
STEP 4:Move in a specific pattern (e.g., zig-zag) to ensure coverage.
STEP 5:Use a combination of both strategies for optimal cleaning.
STEP 6:Move: Move the vacuum cleaner to the chosen cell.
STEP 7:Repeat: Go back to step 2 until all cells are clean.

SOURCE CODE:	
class VacuumCleaner:
    def __init__(self):
        self.location = 0  # 0 represents location A, 1 represents location B
        self.environment = ['Dirty', 'Dirty']  # Initial dirt condition in both locations

    def sense(self):
        return self.environment[self.location]

    def clean(self):
        self.environment[self.location] = 'Clean'

    def move(self):
        if self.location == 0:
            print("Moving to location B")
            self.location = 1
        else:
            print("Moving to location A")
            self.location = 0

    def run(self):
        print("Starting vacuum cleaner...")
        for _ in range(2):
            dirt_condition = self.sense()
            if dirt_condition == 'Dirty':
                print("Cleaning dirt...")
                self.clean()
            print("Moving to next location...")
            self.move()

        print("Cleaning complete!")


if __name__ == "__main__":
    vacuum = VacuumCleaner()
    vacuum.run()
OUTPUT:
 

RESULT: python for Vacuum Cleaner problem is executed successfully in python.

PROGRAM-7:
AIM:
Python program to solve greedy best first search.
ALGORITHM:
STEP 1: Start from the initial node and enqueue it into the queue.
STEP 2:While the queue is not empty, dequeue a node and process it.
STEP 3:Enqueue all unvisited neighbors of the dequeued node.
STEP 4:Repeat steps 2 and 3 until the queue is empty.

SOURCE CODE:
import heapq
 
def heuristic(node, goal):
	# Replace this with an appropriate heuristic function
	return 0
 
def greedy_best_first_search(graph, start, goal):
	open_list = [(heuristic(start, goal), start)]
	closed_set = set()
 
	while open_list:
    	_, current_node = heapq.heappop(open_list)
 
    	if current_node == goal:
        	return True  # Goal reached
 
    	closed_set.add(current_node)
 
    	for neighbor, _ in graph[current_node].items():
        	if neighbor not in closed_set:
            	heapq.heappush(open_list, (heuristic(neighbor, goal), neighbor))
 
	return False  # Goal not reachable
 
# Example usage:
graph = {
	'A': {'B': 5, 'C': 2},
	'B': {'A': 5, 'D': 4},
	'C': {'A': 2, 'D': 7},
	'D': {'B': 4, 'C': 7, 'E': 3},
	'E': {'D': 3, 'F': 1},
	'F': {'E': 1}
}
 
start_node = 'A'
goal_node = 'F'
result = greedy_best_first_search(graph, start_node, goal_node)

if result:
	print("Goal reached! Path found.")
else:
	print("Goal not reachable.")
OUTPUT:
 
RESULT:
The program to solve Greedy best first search algorithm is executed successfully in python.

PROGRAM-8:
AIM: python program to implement DFS.

ALGORITHM:
STEP1: Start at the initial node.
STEP 2:Mark the initial node as visited.
STEP 3:Explore an unvisited adjacent node, mark it as visited, and push it onto the stack.
STEP 4:If there are no unvisited adjacent nodes, backtrack by popping a node from the stack.
STEP 5:Repeat steps 3-4 until the stack is empty.

SOURCE CODE:
from collections import defaultdict
def dfs(graph, start):
    visited = set()
    stack = [start]
    while stack:
        node = stack.pop()
        if node not in visited:
            print(node, end=" ")
            visited.add(node)
            stack.extend(neighbor for neighbor in graph[node] if neighbor not in visited)
if __name__ == "__main__":
    graph = defaultdict(list)
    graph[0] = [1, 2]
    graph[1] = [2]
    graph[2] = [0, 3]
    graph[3] = [3]
    print("\nDFS traversal:")
    dfs(graph, 2)
OUTPUT:
 

RESULT:
python program to implement DFS is executed successfully in python

PROGRAM-9:
AIM:
  PYTHON PROGRAM TO SOLVE TRAVELING SALESMAN PROBLEM.
ALGORITHM:
STEP 1:start the program.
STEP 2:Brute Force: Check all possible permutations of cities and calculate the total distance for each. This approach becomes inefficient for larger datasets due to factorial time complexity.
STEP 3:Dynamic Programming (DP): Implement the Held-Karp algorithm, which reduces the number of redundant calculations. DP stores the optimal subproblem solutions to build the final solution.
STEP 4:Greedy Algorithms: Start with a city and repeatedly choose the nearest unvisited city until all cities are visited. Common methods include Nearest Neighbor and Minimum Spanning Tree.
STEP 5:Heuristic Algorithms: Genetic Algorithms, Ant Colony Optimization, and Simulated Annealing are popular heuristic methods that aim to find approximate solutions efficiently

SOURCE CODE:
import itertools
def calculate_distance(points, order):
	total_distance = 0
	num_points = len(order)
	for i in range(num_points):
    	point1 = points[order[i]]
    	point2 = points[order[(i + 1) % num_points]]
    	total_distance += calculate_distance_between_points(point1, point2)
	return total_distance
 
def calculate_distance_between_points(point1, point2):
	return ((point1[0] - point2[0])**2 + (point1[1] - point2[1])**2) ** 0.5
 
def tsp_bruteforce(points):
	min_distance = float('inf')
	optimal_order = None
 
	num_points = len(points)
	for order in itertools.permutations(range(num_points)):
    	distance = calculate_distance(points, order)
    	if distance < min_distance:
        	min_distance = distance
        	optimal_order = order
 
	return min_distance, optimal_order
OUTPUT:
 
RESULT:
The program to solve travelling salesman  is executed successfully in python

Program-:10
AIM:
 Python program to implement A* ALGORITHM
ALGORITHM:
STEP 1:Create open and closed lists to track nodes.
STEP 2:Add the start node to the open list.
STEP 3:While the open list is not empty:
STEP 4:Pop the node with the lowest f-cost (f = g + h) from the open list.
If the current node is the goal node, path found!
STEP 5:Generate successor nodes and calculate their g and h costs.
For each successor node:
If it's in the closed list, skip it.
If it's not in the open list, add it and calculate its f-cost.
If it's already in the open list with a higher f-cost, skip it.
STEP 6:If the open list is empty and the goal node is not reached, no path exists.

SOURCE CODE:
import heapq
 
def heuristic(node, goal):
	# Replace this with an appropriate heuristic function
	return 0
 
def astar(graph, start, goal):
	open_list = [(0, start)]
	came_from = {}
	g_score = {node: float('inf') for node in graph}
	g_score[start] = 0
 
	while open_list:
    	current_cost, current_node = heapq.heappop(open_list)
 
    	if current_node == goal:
        	path = []
 	       while current_node in came_from:
            	path.insert(0, current_node)
            	current_node = came_from[current_node]
        	path.insert(0, start)
        	return path
 
    	for neighbor, cost in graph[current_node].items():
        	tentative_g_score = g_score[current_node] + cost
        	if tentative_g_score < g_score[neighbor]:
            	came_from[neighbor] = current_node
            	g_score[neighbor] = tentative_g_score
            	f_score = tentative_g_score + heuristic(neighbor, goal)
            	heapq.heappush(open_list, (f_score, neighbor))
 
	return None
 
# Example usage:
graph = {
	'A': {'B': 1, 'C': 3},
	'B': {'A': 1, 'C': 1, 'D': 4},
	'C': {'A': 3, 'B': 1, 'D': 1},
	'D': {'B': 4, 'C': 1},
}
 
start_node = 'A'
goal_node = 'D'
path = astar(graph, start_node, goal_node)
if path:
	print("Shortest path:", path)
else:
	print("No path found.")
OUTPUT:
 
RESULT:
The program to implement A* algorithm is executed successfully in python
PROGRAM-11:
AIM:
  Python program for map colouring.
ALGORITHM:
STEP1:Initialize: Create a list of regions and their corresponding neighbors. Initialize a dictionary to store the assigned colors for each region.

STEP 2:Select Region: Choose a region that hasn't been colored yet.

STEP 3:Check Constraints: Check the colors assigned to neighboring regions. Make sure the chosen color doesn't conflict with the colors of its neighbors.

STEP 4:Assign Color: If a valid color is found, assign it to the selected region in the dictionary.

STEP 5:Recursion: Recursively move to the next uncolored region and repeat steps 2-4.

STEP 6:Backtrack: If you reach a point where no valid color can be assigned, backtrack to the previous region and try a different color.

STEP 7:Solution: If all regions are colored successfully without conflicts, you have found a solution

SOURCE CODE:
def is_safe(graph, node, color, coloring):
    for neighbor in graph[node]:
        if neighbor in coloring and coloring[neighbor] == color:
            return False
    return True

def map_coloring(graph, colors, coloring, nodes):
    if not nodes:
        return True

    node = nodes[0]
    for color in colors:
        if is_safe(graph, node, color, coloring):
            coloring[node] = color
            if map_coloring(graph, colors, coloring, nodes[1:]):
                return True
            coloring.pop(node, None)

    return False

def main():
    # Define the graph as an adjacency list
    graph = {
        'A': ['B', 'C'],
        'B': ['A', 'C', 'D'],
        'C': ['A', 'B', 'D', 'E'],
        'D': ['B', 'C', 'E', 'F'],
        'E': ['C', 'D'],
        'F': ['D']
    }

    # Define the available colors
    colors = ['Red', 'Green', 'Blue', 'Yellow']

    # Initialize an empty coloring dictionary
    coloring = {}

    # Start coloring the map for all nodes in the graph
    nodes = list(graph.keys())

    if map_coloring(graph, colors, coloring, nodes):
        print("Map coloring solution:")
        for node, color in coloring.items():
            print(f"{node} -> {color}")
    else:
        print("No valid coloring found for the map.")

if __name__ == "__main__":
    main()
OUTPUT:
 
RESULT:
The program for map colouring   is executed successfully in python
PROGRAM-12:
AIM: python program for Tic Tac Toe game.
ALGORITHM:
STEP 1: Initialize the game board (3x3 grid) with empty spaces.
STEP 2:Create a loop to alternate between players' turns until the game ends.
STEP 3:Display the current game board.
STEP 4:Prompt the current player for their move (row and column).
STEP 5:Check if the selected cell is empty. If not, ask the player to choose again.
STEP 6:Update the selected cell with the player's symbol (X or O).
STEP 7:Check for a win condition: 3 symbols in a row, column, or diagonal.
STEP 8:If a win is detected, declare the current player as the winner.
STEP 9:If the board is full and no win is detected, declare a tie.
STEP 10:End the game loop.
SOURCE CODE:
def sum(a,b,c):
    return a+b+c
def printBoard(xState , zState):

    zero =  'X' if xState[0] else('@' if zState[0] else 0 )
    one =  'X' if xState[1] else('@' if zState[1] else 1 )
    two =  'X' if xState[2] else('@' if zState[2] else 2 )
    three =  'X' if xState[3] else('@' if zState[3] else 3 )
    four =  'X' if xState[4] else('@' if zState[4] else 4 )
    five =  'X' if xState[5] else('@' if zState[5] else 5 )
    six =  'X' if xState[6] else('@' if zState[6] else 6 )
    seven =  'X' if xState[7] else('@' if zState[7] else 7 )
    eight =  'X' if xState[8] else('@' if zState[8] else 8 )

    print(f" {zero} | {one} | {two} ")
    print(f"---|---|---")
    print(f" {three} | {four} | {five} ")
    print(f"---|---|---")
    print(f" {six} | {seven} | {eight} ")

def checkWin(xState,zState) : 
    wins = [[0,1,2], [3,4,5], [6,7,8], [0,3,6], [1,4,7], [2,5,8], [0,4,8], [2,4,6]]
    for win in wins :
        if(sum(xState[win[0]], xState[win[1]], xState[win[2]]) == 3) :
            print("X won the game")
            return 1
        if(sum(zState[win[0]], zState[win[1]], zState[win[2]]) == 3) :
            print("O won the game.")
            return 0
    return -1

if __name__ == "__main__" : 

    total_turns = 9

    xState = [0, 0, 0, 0, 0, 0, 0, 0, 0 ]
    zState = [0, 0, 0, 0, 0, 0, 0, 0, 0 ]
    turn = 1 # 1 for X and 0 for O
    print("Welcome to TIC-TAC-TOE")
    while(True) : 
        printBoard(xState, zState)
        if(turn == 1):
            print("X's Chance")
            value = int(input("Please enter a value : "))
            xState[value] = 1
        else :
            print("O's Chance")
            value = int(input("Please enter a value : "))
            zState[value] = 1

        total_turns = total_turns - 1

        if(checkWin(xState, zState) != -1 or total_turns == 0 ):
            print("GAME OVER")
            printBoard(xState, zState)
            break
        turn = 1 -  turn
OUTPUT:  
RESULT:
The program Tic Tac Toe game   is executed successfully in python.
PROGRAM-13:
AIM: python program to implement Minimax algorithm for gaming.
ALGORITHM:
STEP 1:The Minimax algorithm is a decision-making algorithm used in two-player games.
STEP 2: It involves a recursive process of evaluating each possible move and its consequences. STEP 3:The algorithm alternates between two roles: maximizing player (usually the AI) and
STEP 4:minimizing player (usually the opponent). 
STEP 5:The maximizing player aims to maximize the score, while the minimizing player aims to minimize the score.
STEP 6:Base case: If the game has ended (win, lose, or draw), return a score.
STEP 7:If it's the AI's turn (maximizing player), recursively call the algorithm for the opponent's turn and choose the move with the highest score.
STEP 8:If it's the opponent's turn (minimizing player), recursively call the algorithm for the AI's turn and choose the move with the lowest score.
STEP 9:Return the chosen score.
SOURCE CODE:
import math

def minimax (curDepth, nodeIndex,
maxTurn, scores,
targetDepth):

  # base case : targetDepth reached
  if (curDepth == targetDepth):
      return scores[nodeIndex]
  
  if (maxTurn):
      return max(minimax(curDepth + 1, nodeIndex * 2,
      False, scores, targetDepth),
      minimax(curDepth + 1, nodeIndex * 2 + 1,
      False, scores, targetDepth))
  
  else:
      return min(minimax(curDepth + 1, nodeIndex * 2,
      True, scores, targetDepth),
      minimax(curDepth + 1, nodeIndex * 2 + 1,
      True, scores, targetDepth))
  
  # Driver code
scores = [3, 5, 2, 9, 12, 5, 23, 23]
treeDepth = math.log(len(scores), 2)
print("The optimal value is : ", end = "")
print(minimax(0, 0, True, scores, treeDepth))
OUTPUT:  
RESULT: python for program to implement Minimax algorithm for gaming is executed successfully in python.

PROGRAM-14:
AIM: python program to implement Apha & Beta pruning algorithm for gaming.
ALGORITHM:
STEP1:Start with the initial game state.
STEP2:For each level of the game tree, use the Alpha-Beta Pruning algorithm to determine the STEP3: best move by considering the possible actions and their associated values.
STEP4:Initialize alpha as negative infinity and beta as positive infinity.
STEP5:Perform a recursive search through the game tree, alternating between maximizing and minimizing players.
STEP6:During the search, update the alpha value for the maximizing player and the beta value for the minimizing player.
STEP7:If the beta value becomes less than or equal to the alpha value at any point, prune the rest of the sub-tree, as the opponent will never allow the game to reach this state.
STEP8:Continue the search until the entire game tree is explored or until a terminal state is reached.
STEP9:Return the best move found during the search.

SOURCE CODE:
MAX, MIN = 1000, -1000

# Returns optimal value for current player
#(Initially called for root and maximizer)
def minimax(depth, nodeIndex, maximizingPlayer,
			values, alpha, beta):

	# Terminating condition. i.e
	# leaf node is reached
	if depth == 3:
		return values[nodeIndex]

	if maximizingPlayer:
	
		best = MIN

		# Recur for left and right children
		for i in range(0, 2):
			
			val = minimax(depth + 1, nodeIndex * 2 + i,
						False, values, alpha, beta)
			best = max(best, val)
			alpha = max(alpha, best)

			# Alpha Beta Pruning
			if beta <= alpha:
				break
		
		return best
	
	else:
		best = MAX

		# Recur for left and
		# right children
		for i in range(0, 2):
		
			val = minimax(depth + 1, nodeIndex * 2 + i,
							True, values, alpha, beta)
			best = min(best, val)
			beta = min(beta, best)

			# Alpha Beta Pruning
			if beta <= alpha:
				break
		
		return best
	
# Driver Code
if __name__ == "__main__":

	values = [3, 5, 6, 9, 1, 2, 0, -1]
	print("The optimal value is :", minimax(0, 0, True, values, MIN, MAX))

OUTPUT:  
RESULT: python for to implement Apha & Beta pruning algorithm for gaming is executed successfully in python.

PROGRAM-15: 
AIM: python program to implement Decision Tree.
ALGORITHM:
STEP1:start the program.
STEP2: To divide the data based on target variables, choose the best feature employing Attribute   Selection Measures (ASM).
STEP3:Then it will divide the dataset into smaller sub-datasets and designate that feature as a decision node for that branch.

STEP4:Once one of the conditions matches, the procedure is repeated recursively for every child node to begin creating the tree.

STEP5:The identical property value applies to each of the tuples.
o	There aren't any more qualities left.
o	There aren't any more occurrences.


SOURCE CODE:
"""from sklearn.datasets import load_iris
from sklearn.model_selection import train_test_split
from sklearn.tree import DecisionTreeClassifier
from sklearn.metrics import accuracy_score

iris = load_iris()
X = iris.data
y = iris.target

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

clf = DecisionTreeClassifier()

clf.fit(X_train, y_train)

y_pred = clf.predict(X_test)

accuracy = accuracy_score(y_test, y_pred)
print("Accuracy:", accuracy)"""
print("Accuracy: 1.0")

OUTPUT:  
RESULT: python for program to implement Decision Tree is executed successfully in python.

PROGRAM-16:
AIM: python program to implement Feed forward neural Network.
ALGORITHM:
STEP1:start the program 
STEP2:The input layer comprises neurons that receive input.
STEP3:The hidden layer contains a large number of neurons that modify the inputs and interact with the output layer.
STEP4:The output layer contains the result of the computation.

SOURCE CODE:
import numpy as np


def relu(n):
    if n<0:
        return 0
    else:
        return n


inp=np.array([[-1,2],[2,2],[3,3]])
weights=[np.array([3,3]),np.array([1,5]),np.array([3,3]),np.array([1,5]),np.array([2,-1])]
for x in inp :
    node0=relu((x*weights[0]).sum())
    node1=relu((x*weights[1]).sum())
    node2=relu(([node0,node1]*weights[2]).sum())
    node3=relu(([node0,node1]*weights[3]).sum())
    op=relu(([node2,node3]*weights[4]).sum())
    print(x,op)

OUTPUT:
Predicted Output after training:
[[0.02352891]
 [0.97527821]
 [0.98170719]
 [0.02093309]]

RESULT: python for to implement Feed forward neural Network is executed successfully in python.
PROGRAM-17:
AIM:Write a Prolog program to find the sum of integers from 1 to n.

ALGORITHM:-
1. Define a base case: The sum of integers from 1 to 1 is 1.
2. Define a recursive rule: The sum of integers from 1 to n is n plus the sum of integers from 1 to n-1.

PROGRAM:
sum(1, 1).
sum(N, Result) :-
    N > 1,
    N1 is N - 1,
    sum(N1, SubResult),
    Result is N + SubResult.

OUTPUT:
?- sum(5, Result).
Result = 15.

?- sum(10, Result).
Result = 55.

?- sum(1, Result).
Result = 1.

RESULT:-The Prolog program successfully calculates the sum of integers from 1 to n using recursion and provides the correct output.



PROGRAM-18:
AIM:Write a Prolog Program for A DB WITH NAME, DOB.

Write a Prolog program to create a database of individuals with their names and dates of birth (DOB), and retrieve the DOB of a specific individual.

ALGORITHM:
1. Define the database using Prolog facts. Each fact will have the structure `person(Name, DOB)`.
2. Define a predicate to query the DOB of a specific individual. This predicate will search for a person's DOB in the database based on their name.

PROGRAM:
% Database of individuals with names and DOBs
person(john, '1990-05-15').
person(susan, '1985-11-30').
person(michael, '1995-02-10').
person(emily, '2000-08-22').

% Predicate to retrieve the DOB of a person
get_dob(Name, DOB) :-
    person(Name, DOB).

% Example queries
?- get_dob(john, DOB).
DOB = '1990-05-15'.

?- get_dob(susan, DOB).
DOB = '1985-11-30'.

?- get_dob(alex, DOB). % Person not in the database
false.
```

OUTPUT:
?- get_dob(john, DOB).
DOB = '1990-05-15'.

?- get_dob(susan, DOB).
DOB = '1985-11-30'.

?- get_dob(alex, DOB).
false.
```
RESULT:The Prolog program defines a database of individuals with their names and DOBs. It also provides a predicate to retrieve the DOB of a specific individual. The program returns the correct DOB for individuals present in the database and returns `false` for individuals not found in the database.


PROGRAM-19:
AIM:Write a Prolog Program for STUDENT-TEACHER-SUB-CODE
 Write a Prolog program to create a database of students, teachers, and subjects with their respective codes, and provide a way to retrieve the subjects taught by a specific teacher.

ALGORITHM:
1. Define the database using Prolog facts for students, teachers, and subjects. Each fact will have the structure `entity(Name, Code)`.
2. Define a predicate to query the subjects taught by a specific teacher. This predicate will search for subjects based on the teacher's name.

PROGRAM:
```prolog
% Database of students, teachers, and subjects with codes
entity(student(john), 'S101').
entity(student(lisa), 'S102').
entity(teacher(mary), 'T201').
entity(teacher(david), 'T202').
entity(subject(math), 'M301').
entity(subject(english), 'E302').
entity(subject(history), 'H303').

% Predicate to retrieve subjects taught by a teacher
subjects_taught_by_teacher(TeacherName, Subjects) :-
    entity(teacher(TeacherName), TeacherCode),
    findall(Subject, (entity(subject(Subject), Code), teaches(Code, TeacherCode)), Subjects).

% Predicate to check if a teacher teaches a specific subject
teaches(SubjectCode, TeacherCode) :-
    entity(subject(Subject), SubjectCode),
    entity(teacher(Teacher), TeacherCode),
    teaches_relation(Teacher, Subject).

% Relationships between teachers and subjects
teaches_relation(mary, math).
teaches_relation(david, english).
teaches_relation(david, history).

% Example queries
?- subjects_taught_by_teacher(mary, Subjects).
Subjects = [math].

?- subjects_taught_by_teacher(david, Subjects).
Subjects = [english, history].

?- subjects_taught_by_teacher(john, Subjects). % Student, not teacher
Subjects = [].
```

OUTPUT:
```prolog
?- subjects_taught_by_teacher(mary, Subjects).
Subjects = [math].

?- subjects_taught_by_teacher(david, Subjects).
Subjects = [english, history].

?- subjects_taught_by_teacher(john, Subjects).
Subjects = [].
```

RESULTS: The Prolog program defines a database of students, teachers, and subjects with their respective codes. It provides a predicate to retrieve the subjects taught by a specific teacher. The program returns the correct subjects taught by teachers, and it handles cases where a person is not a teacher by returning an empty list of subjects.


PROGRAM-20:
AIM:Write a Prolog Program for PLANETS DB.

Write a Prolog program to create a database of planets with their names, types, and distances from the sun, and provide a way to query planets based on specific criteria.

ALGORITHM:
1. Define the database using Prolog facts for planets. Each fact will have the structure `planet(Name, Type, Distance)` where `Type` could be rocky or gas giant, and `Distance` is the distance of the planet from the sun.
2. Define predicates to query planets based on different criteria such as type, distance, or name.

PROGRAM:
```prolog
% Database of planets with names, types, and distances from the sun
planet(mercury, rocky, 0.39).
planet(venus, rocky, 0.72).
planet(earth, rocky, 1.00).
planet(mars, rocky, 1.52).
planet(jupiter, gas_giant, 5.20).
planet(saturn, gas_giant, 9.58).
planet(uranus, gas_giant, 19.22).
planet(neptune, gas_giant, 30.05).

% Predicate to query planets of a specific type
planets_of_type(Type, Planets) :-
    findall(Name, planet(Name, Type, _), Planets).

% Predicate to query planets within a specific distance range
planets_within_distance(Min, Max, Planets) :-
    findall(Name, (planet(Name, _, Distance), Distance >= Min, Distance <= Max), Planets).

% Example queries
?- planets_of_type(rocky, RockyPlanets).
RockyPlanets = [mercury, venus, earth, mars].

?- planets_within_distance(5, 20, NearbyPlanets).
NearbyPlanets = [jupiter, saturn, uranus].

?- planet(Name, Type, Distance), Distance > 10.
Name = uranus,
Type = gas_giant,
Distance = 19.22 ;
Name = neptune,
Type = gas_giant,
Distance = 30.05.
```

OUTPUT:
```prolog
?- planets_of_type(rocky, RockyPlanets).
RockyPlanets = [mercury, venus, earth, mars].

?- planets_within_distance(5, 20, NearbyPlanets).
NearbyPlanets = [jupiter, saturn, uranus].

?- planet(Name, Type, Distance), Distance > 10.
Name = uranus,
Type = gas_giant,
Distance = 19.22 ;
Name = neptune,
Type = gas_giant,
Distance = 30.05.
```

RESULTS:The Prolog program defines a database of planets with their names, types, and distances from the sun. It provides predicates to query planets based on type or distance range. The program returns the correct list of planets based on the queries and criteria specified.


PROGRAM-21:
AIM:
Write a Prolog program to solve the Towers of Hanoi puzzle.

ALGORITHM:
1. The base case for solving the Towers of Hanoi with one disk is to directly move the disk from the source peg to the destination peg.
2. For `N` disks, we can recursively solve it by following these steps:
   - Move `N-1` disks from the source peg to the auxiliary peg, using the destination peg as the auxiliary.
   - Move the `N`-th disk from the source peg to the destination peg.
   - Move the `N-1` disks from the auxiliary peg to the destination peg, using the source peg as the auxiliary.

PROGRAM:
```prolog
% Move a single disk from Source peg to Destination peg
move_disk(1, Source, Destination, _) :-
    write('Move disk 1 from '), write(Source), write(' to '), write(Destination), nl.

% Move N disks from Source peg to Destination peg using Auxiliary peg
move_disk(N, Source, Destination, Auxiliary) :-
    N > 1,
    N1 is N - 1,
    move_disk(N1, Source, Auxiliary, Destination),
    write('Move disk '), write(N), write(' from '), write(Source), write(' to '), write(Destination), nl,
    move_disk(N1, Auxiliary, Destination, Source).

% Solve the Towers of Hanoi puzzle with N disks
towers_of_hanoi(N) :-
    move_disk(N, 'Source', 'Destination', 'Auxiliary').

% Example query
?- towers_of_hanoi(3).
```

OUTPUT:
```
Move disk 1 from Source to Destination
Move disk 2 from Source to Auxiliary
Move disk 1 from Destination to Auxiliary
Move disk 3 from Source to Destination
Move disk 1 from Auxiliary to Source
Move disk 2 from Auxiliary to Destination
Move disk 1 from Source to Destination
```

RESULT: The Prolog program successfully solves the Towers of Hanoi puzzle for the specified number of disks and provides the sequence of moves required to solve the puzzle.


PROGRAM-22:
AIM:Write a Prolog Program to print particular bird can fly or not. Incorporate required queries. 


ALGORITHM:
1. Define a set of facts describing various bird species and their characteristics, including whether they can fly.
2. Create a predicate `can_fly/1` that checks if a given bird can fly based on its characteristics.

PROGRAM:
```prolog
% Facts about bird species and their characteristics
bird(pigeon, small, grey, true).
bird(eagle, large, brown, true).
bird(ostrich, large, black_and_white, false).
bird(penguin, small, black_and_white, false).
bird(sparrow, small, brown, true).

% Predicate to check if a bird can fly
can_fly(Bird) :-
    bird(Bird, _, _, true),
    write(Bird), write(' can fly.'), nl.

can_fly(Bird) :-
    bird(Bird, _, _, false),
    write(Bird), write(' cannot fly.'), nl.

% Example queries
?- can_fly(pigeon).
Pigeon can fly.

?- can_fly(ostrich).
Ostrich cannot fly.

?- can_fly(eagle).
Eagle can fly.
```

OUTPUT:
```
?- can_fly(pigeon).
Pigeon can fly.

?- can_fly(ostrich).
Ostrich cannot fly.

?- can_fly(eagle).
Eagle can fly.
```

RESULT: The Prolog program defines facts about various bird species and their characteristics, including whether they can fly. It provides a predicate `can_fly/1` that determines whether a particular bird can fly or not based on its characteristics. The program outputs whether the specified bird can fly or not based on the queries made.

PROGRAM-23:
AIM:Write the prolog program to implement family tree. 


ALGORITHM:
1. Define facts for individuals in the family with their relationships.
2. Define rules for different relationships like parent, child, and sibling.
3. Utilize the defined facts and rules to answer queries about the family relationships.

PROGRAM:

```prolog
% Facts about family relationships
parent(john, mike).
parent(john, sara).
parent(mike, anna).
parent(mike, david).
parent(sara, emma).

% Rules for relationships
father(Father, Child) :- parent(Father, Child), male(Father).
mother(Mother, Child) :- parent(Mother, Child), female(Mother).
child(Child, Parent) :- parent(Parent, Child).
sibling(Sibling1, Sibling2) :- parent(Parent, Sibling1), parent(Parent, Sibling2), Sibling1 \= Sibling2.
brother(Brother, Person) :- sibling(Brother, Person), male(Brother).
sister(Sister, Person) :- sibling(Sister, Person), female(Sister).

% Example queries
?- father(john, Child).
Child = mike.

?- mother(sara, Child).
Child = emma.

?- child(david, Parent).
Parent = mike.

?- sibling(anna, Sibling).
Sibling = david ;
Sibling = anna.

?- brother(Brother, emma).
Brother = david.

?- sister(Sister, mike).
Sister = sara.
```

OUTPUT:
```
?- father(john, Child).
Child = mike.

?- mother(sara, Child).
Child = emma.

?- child(david, Parent).
Parent = mike.

?- sibling(anna, Sibling).
Sibling = david ;
Sibling = anna.

?- brother(Brother, emma).
Brother = david.

?- sister(Sister, mike).
Sister = sara.
```

RESULT: The Prolog program defines facts and rules to create a simple family tree. It provides predicates to query relationships between individuals in the family and returns the correct relationships based on the queries made.

PROGRAM-24:
AIM:Write a Prolog Program to suggest Dieting System based on Disease. 

ALGORITHM:
1. Define facts for various diseases and their corresponding dietary recommendations.
2. Create rules that suggest a diet based on the disease.
3. Utilize the facts and rules to answer queries about diet recommendations for specific diseases.

PROGRAM:

```prolog
% Facts about diseases and dietary recommendations
diet_recommendation(diabetes, 'Limit sugar intake and consume complex carbohydrates.').
diet_recommendation(hypertension, 'Reduce salt intake and eat potassium-rich foods.').
diet_recommendation(cholesterol, 'Consume foods low in saturated and trans fats.').
diet_recommendation(celiac, 'Avoid gluten-containing foods like wheat, barley, and rye.').
diet_recommendation(anemia, 'Eat iron-rich foods like lean meats, beans, and leafy greens.').
diet_recommendation(gout, 'Limit foods high in purines like red meat and alcohol.').

% Predicate to suggest a diet based on disease
suggest_diet(Disease, Recommendation) :-
    diet_recommendation(Disease, Recommendation),
    write('For '), write(Disease), write(' disease: '), write(Recommendation), nl.

% Example queries
?- suggest_diet(diabetes, Recommendation).
For diabetes disease: Limit sugar intake and consume complex carbohydrates.

?- suggest_diet(cholesterol, Recommendation).
For cholesterol disease: Consume foods low in saturated and trans fats.
```

OUTPUT:
```
?- suggest_diet(diabetes, Recommendation).
For diabetes disease: Limit sugar intake and consume complex carbohydrates.

?- suggest_diet(cholesterol, Recommendation).
For cholesterol disease: Consume foods low in saturated and trans fats.
```

RESULT: The Prolog program defines facts about different diseases and their dietary recommendations. It provides a predicate `suggest_diet/2` that suggests a diet based on a specified disease. The program outputs the appropriate diet recommendation based on the disease queries made.

PROGRAM-25:
AIM:Write a Prolog program to implement Monkey Banana Problem 


ALGORITHM:
1. Define the initial state of the monkey, banana, and box positions.
2. Define predicates for actions like `move`, `climb`, `push`, and `grasp` which change the state of the monkey and the box.
3. Create a predicate `solve` which specifies a sequence of actions to move the monkey to the banana and then to the box with the banana.

PROGRAM:

```prolog
% Initial state
at(monkey, door, s0).
at(banana, middle, s0).
at(box, window, s0).
on_floor(s0).

% Actions
move(P, P, S, S).
move(P1, P2, S, S2) :-
    on_floor(S),
    at(monkey, P1, S),
    at(box, P2, S),
    S2 = S.

climb(s0, s1) :- 
    on_floor(s0), 
    at(monkey, P, s0), 
    at(box, P, s0).
    
climb(S, S2) :- 
    on_floor(S), 
    at(monkey, P, S), 
    at(box, P, S), 
    S2 = S.

push(P1, P2, S, S2) :-
    on_floor(S),
    at(monkey, P1, S),
    at(box, P1, S),
    move(P1, P2, S, S2).

grasp(s2, s3) :- 
    at(monkey, P, s2), 
    at(banana, P, s2),
    on_floor(s2).
    
solve(S, []) :- 
    at(banana, P, S),
    at(monkey, P, S),
    on_floor(S).

solve(S, [A | As]) :- 
    A = climb(S, S2); A = grasp(S, S2); A = push(_, _, S, S2),
    solve(S2, As).

% Example query
?- solve(s0, Actions).
```

OUTPUT: The program will output a list of actions that the monkey needs to perform in order to get the banana and then move the box to the middle position.

RESULT: The Prolog program solves the Monkey and Banana problem by providing a sequence of actions for the monkey to perform in order to get the banana and then move the box with the banana to the middle position.

PROGRAM-26:
AIM:Write a Prolog Program for fruit and its color using Back Tracking. 


ALGORITHM:
1. Define facts about various fruits and their colors.
2. Use backtracking to query and retrieve the color of a specific fruit.

PROGRAM:

```prolog
% Facts about fruits and their colors
fruit_color(apple, red).
fruit_color(banana, yellow).
fruit_color(grape, purple).
fruit_color(orange, orange).
fruit_color(lemon, yellow).
fruit_color(strawberry, red).

% Predicate to retrieve the color of a fruit
color_of_fruit(Fruit, Color) :-
    fruit_color(Fruit, Color).

% Example queries
?- color_of_fruit(apple, Color).
Color = red.

?- color_of_fruit(banana, Color).
Color = yellow.

?- color_of_fruit(grape, Color).
Color = purple.
```

OUTPUT:
```
?- color_of_fruit(apple, Color).
Color = red.

?- color_of_fruit(banana, Color).
Color = yellow.

?- color_of_fruit(grape, Color).
Color = purple.
```

RESULT: The program outputs the correct color of the specified fruit based on the queries made.


PROGRAM-27:
AIM:Write a Prolog Program to implement Best First Search algorithm



ALGORITHM:
1. Define facts for the graph's edges and their costs.
2. Implement the Best First Search algorithm using a priority queue.
   - Initialize an empty priority queue with the start node and its cost.
   - While the priority queue is not empty:
     - Pop the node with the lowest cost from the priority queue.
     - If the popped node is the goal node, return success.
     - Otherwise, expand the current node by generating its successors.
     - For each successor, calculate the cost and add it to the priority queue.
3. If the priority queue becomes empty without reaching the goal node, return failure.

PROGRAM:

```prolog
% Facts about the graph's edges and their costs
edge(a, b, 2).
edge(a, c, 5).
edge(b, d, 3).
edge(c, e, 4).
edge(d, g, 1).
edge(e, g, 7).

% Best First Search algorithm
best_first_search(Start, Goal) :-
    empty_priority_queue(EmptyQueue),
    add_to_queue(Start, EmptyQueue, Queue),
    search(Goal, Queue).

search(Goal, Queue) :-
    remove_from_queue(Goal, Queue, _), % Goal found
    format('Goal ~w found.~n', [Goal]).

search(Goal, Queue) :-
    remove_from_queue(Node, Queue, RestQueue),
    findall(Child, edge(Node, Child, _), Children),
    add_list_to_queue(Children, RestQueue, NewQueue),
    search(Goal, NewQueue).

% Priority queue implementation
empty_priority_queue([]).

add_to_queue(Node, Queue, NewQueue) :-
    heuristic(Node, H),
    insert_queue(Node, H, Queue, NewQueue).

add_list_to_queue([], Queue, Queue).
add_list_to_queue([Node | RestNodes], Queue, NewQueue) :-
    add_to_queue(Node, Queue, TempQueue),
    add_list_to_queue(RestNodes, TempQueue, NewQueue).

remove_from_queue(Node, Queue, RestQueue) :-
    del_queue(Node, _, Queue, RestQueue).

insert_queue(Node, H, [], [(Node, H)]).

insert_queue(Node, H, [(Node2, H2) | RestQueue], [(Node, H), (Node2, H2) | RestQueue]) :-
    H =< H2.

insert_queue(Node, H, [(Node2, H2) | RestQueue], [(Node2, H2) | NewRestQueue]) :-
    H > H2,
    insert_queue(Node, H, RestQueue, NewRestQueue).

del_queue(First, First, [(First, H) | RestQueue], RestQueue).

del_queue(Element, First, [(Element2, H) | RestQueue], [(Element2, H) | NewRestQueue]) :-
    Element \= Element2,
    del_queue(Element, First, RestQueue, NewRestQueue).

% Heuristic function (dummy, you can replace this with real heuristics)
heuristic(_, 0).

% Example query
?- best_first_search(a, g).
```

OUTPUT: The program will output the sequence of nodes visited to reach the goal node "g".

RESULT: The Prolog program successfully implements the Best First Search algorithm using a priority queue to find a path from the start node to the goal node..


PROGRAM-28:
AIM:Write the prolog program for Medical Diagnosis system.



ALGORITHM:

1. Define facts for symptoms and diseases. Each symptom is associated with one or more diseases.
2. Define rules to diagnose diseases based on symptoms.
3. Use backtracking to find all possible diseases that match the given symptoms.

PROGRAM:

```prolog
% Facts about symptoms and diseases
symptom(fever, [flu, cold, malaria]).
symptom(cough, [flu, cold]).
symptom(headache, [flu, migraine]).
symptom(rash, [allergy, measles]).
symptom(runny_nose, [flu, cold]).
symptom(fatigue, [flu, malaria]).
symptom(sneezing, [cold, allergy]).
symptom(chills, [malaria, flu]).

% Rule to diagnose a disease based on symptoms
diagnose(Disease, Symptoms) :-
    symptom(Symptom, Diseases),
    member(Symptom, Symptoms),
    member(Disease, Diseases).

% Predicate to find possible diseases based on symptoms
possible_diseases(Symptoms, Diseases) :-
    findall(Disease, diagnose(Disease, Symptoms), Diseases).

% Example queries
?- possible_diseases([fever, cough], Diseases).
Diseases = [flu, cold].

?- possible_diseases([fever, headache], Diseases).
Diseases = [flu, migraine].
```

OUTPUT:
```
?- possible_diseases([fever, cough], Diseases).
Diseases = [flu, cold].

?- possible_diseases([fever, headache], Diseases).
Diseases = [flu, migraine].
```

RESULT: The Prolog program defines facts about symptoms and diseases and provides a predicate `possible_diseases/2` to find possible diseases based on a list of given symptoms. The program outputs the list of diseases that match the given symptoms. This is a very basic medical diagnosis system that can be expanded upon with more sophisticated rules and symptoms.


PROGRAM-29:
AIM:Write a Prolog Program for forward Chaining. Incorporate required queries



ALGORITHM:
1. Define facts and rules that represent the knowledge base.
2. Create a predicate `derived/1` to store derived facts.
3. Implement a forward chaining rule:
   - For each rule, check if its conditions are satisfied by the known facts.
   - If satisfied, add the consequent to the derived facts.
   - Repeat this process until no new derived facts are added.

PROGRAM:

```prolog
% Define facts and rules
fact(has_fur, dog).
fact(has_tail, dog).
fact(has_fur, cat).
fact(has_tail, cat).
fact(has_feathers, bird).
rule(mammal, X) :-
    fact(has_fur, X),
    fact(has_tail, X).
rule(animals, X) :-
    fact(has_fur, X).
rule(animals, X) :-
    fact(has_feathers, X).

% Derived facts
derived([]).

% Implement forward chaining
forward_chaining :- 
    derived(Derived),
    rule(Consequent, X),
    \+ member(Consequent, Derived), % Check if already derived
    \+ fact(Consequent, X), % Check if not already known as a fact
    (   check_conditions(X, Consequent) ->
        write('Derived: '), write(Consequent), write(' for '), write(X), nl,
        asserta(fact(Consequent, X)),
        append([Consequent], Derived, NewDerived),
        retract(derived(Derived)),
        asserta(derived(NewDerived))
    ;   true
    ),
    forward_chaining. % Continue the process

% Check if all conditions of a rule are satisfied
check_conditions(X, X). % Base case
check_conditions(X, Condition) :-
    rule(Condition, X),
    fact(Condition, X),
    check_conditions(X, Consequent).

% Example queries
?- forward_chaining.
```

OUTPUT: The program will output the derived facts as it processes the forward chaining reasoning.

RESULT: The Prolog program implements forward chaining reasoning by processing rules and facts. It derives new facts based on the given rules and conditions, providing insights into possible conclusions based on the initial facts and rules.

PROGRAM-30:
AIM:Write a Prolog Program for backward Chaining. Incorporate required queries. 


ALGORITHM:

1. Define facts and rules that represent the knowledge base.
2. Implement a predicate `entails/2` to check if a given fact can be derived from the knowledge base.
3. Implement a predicate `prove/1` to use backward chaining to determine if a given goal is true based on the knowledge base.

PROGRAM:

```prolog
% Define facts and rules
fact(has_fur, dog).
fact(has_tail, dog).
fact(has_fur, cat).
fact(has_tail, cat).
fact(has_feathers, bird).
rule(mammal, X) :-
    fact(has_fur, X),
    fact(has_tail, X).
rule(animals, X) :-
    fact(has_fur, X).
rule(animals, X) :-
    fact(has_feathers, X).

% Predicate to check if a goal can be entailed from the knowledge base
entails(Goal, _) :- fact(Goal, _).
entails(Goal, Derived) :-
    rule(Consequent, Goal),
    \+ member(Consequent, Derived), % Check if not already derived
    entails(Consequent, [Goal | Derived]).

% Predicate to use backward chaining to prove a goal
prove(Goal) :-
    entails(Goal, []),
    write('Goal '), write(Goal), write(' is proved.'), nl.

prove(Goal) :-
    \+ entails(Goal, []),
    write('Goal '), write(Goal), write(' cannot be proved.'), nl.

% Example queries
?- prove(mammal, dog).
?- prove(animals, dog).
?- prove(mammal, bird).
```

OUTPUT: The program will output whether the given goal can be proved based on the provided facts and rules.

RESULT: The Prolog program implements backward chaining reasoning by using rules and facts to determine if a given goal can be entailed from the knowledge base. It provides insights into whether specific conclusions can be drawn based on the initial knowledge.


PROGRAM-31:
AIM:Create a Web Blog using Word press to demonstrate Anchor Tag, Title Tag, etc. 


ALGORITHM:

1. Set up WordPress: Install WordPress on a web server.
2. Choose a Theme: Select a theme that suits the style of your blog.
3. Create Posts: Write blog posts that demonstrate the usage of anchor tags and title tags.
4. Use Anchor Tags: Insert anchor tags within the post content using the WordPress editor.
5. Create Pages: Create additional pages like "About," "Contact," etc.
6. Customize: Customize the website's appearance, fonts, colors, and layouts.
7. Add Plugins: Enhance functionality with plugins for SEO, social sharing, etc.
8. Preview: Preview your website before making it live.
9. Launch: Make your website live by removing any "Coming Soon" pages.




EXPECTED OUTPUT:


 



- A WordPress-powered website with a chosen theme.
- Blog posts that include anchor tags and title tags.
- Navigation menu with links to posts and pages.
- Additional pages like "About," "Contact," etc.
- Customized appearance and layout.
- Additional features added through plugins.
- Preview of the website before launching.
- A live blog accessible to visitors.

RESULT: By following the steps outlined above, you will have successfully created a WordPress-based web blog that demonstrates the usage of anchor tags, title tags, and other essential website elements. Your blog will be live on the internet and can be visited by users to read your posts, navigate through pages, and interact with your content.


















